{"version":3,"sources":["../../src/dao/dataDAO.js"],"names":["zips","stocks","DataDAO","injectDB","conn","db","process","env","MFLIX_TR","collection","console","log","e","error","getZips","filters","page","zipsPerPage","queryParams","cursor","find","state","zipsList","totalNumZips","displayCursor","skip","limit","toArray","countDocuments","StockDataDAO","getPrices","pricesPerPage","pricesList","totalNumPrices","ticker","insertStockHist","myDate","Date","upsertResult","updateOne","timestamp","$set","open","high","low","close","upsert","success"],"mappings":"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","sourcesContent":["let zips, stocks;\n\nexport class DataDAO {\n\tstatic async injectDB(conn) {\n\t\tif (zips) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t// movies = await conn.db(process.env.MFLIX_NS).collection('movies');\n\t\t\tzips = await conn.db(process.env.MFLIX_TR).collection('zips');\n\t\t\t// zips = await conn.db(process.env.MFLIX_TR).collection('movies');\n\t\t\t// console.log('zip', zips);\n\t\t\tconsole.log('zip inj');\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to establish collection handles in dataDAO: ${e}`);\n\t\t}\n\t}\n\n\tstatic async getZips({\n\t\t// here's where the default parameters are set for the getMovies method\n\t\tfilters = null,\n\t\tpage = 0,\n\t\tzipsPerPage = 20,\n\t} = {}) {\n\t\tlet queryParams = {};\n\t\t// if (filters) {\n\t\t// \tif ('text' in filters) {\n\t\t// \t\tqueryParams = this.textSearchQuery(filters['text']);\n\t\t// \t} else if ('cast' in filters) {\n\t\t// \t\tqueryParams = this.castSearchQuery(filters['cast']);\n\t\t// \t} else if ('genre' in filters) {\n\t\t// \t\tqueryParams = this.genreSearchQuery(filters['genre']);\n\t\t// \t}\n\t\t// }\n\n\t\t// let { query = {}, project = {}, sort = DEFAULT_SORT } = queryParams;\n\t\tlet cursor;\n\n\t\t// const resa = await zips.find({state: 'AL'});\n\n\t\t// const res = await resa.toArray();\n\t\t// console.log('running getzips', res, '-----');\n\t\ttry {\n\t\t\tcursor = await zips.find({state: 'AL'});\n\n\t\t\t// console.log(cursor.toArray());\n\t\t\t// .project(project)\n\t\t\t// .sort(sort);\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to issue find command, ${e}`);\n\t\t\treturn {zipsList: [], totalNumZips: 0};\n\t\t}\n\n\t\t// const zipsList = await cursor.toArray();\n\t\t// return {zipsList};\n\n\t\tconst displayCursor = cursor.skip(zipsPerPage * page).limit(zipsPerPage);\n\n\t\t// const zipsList = await displayCursor.toArray();\n\t\t// return {zipsList};\n\n\t\ttry {\n\t\t\tconst zipsList = await displayCursor.toArray();\n\t\t\t// const totalNumZips = page === 0 ? await zips.countDocuments(query) : 0;\n\t\t\tconst totalNumZips = page === 0 ? await zips.countDocuments({state: 'AL'}) : 0;\n\n\t\t\treturn {zipsList, totalNumZips};\n\t\t} catch (e) {\n\t\t\tconsole.error(\n\t\t\t\t`Unable to convert cursor to array or problem counting documents, ${e}`\n\t\t\t);\n\t\t\treturn {zipsList: [], totalNumZips: 0};\n\t\t}\n\t}\n}\n\nexport class StockDataDAO {\n\tstatic async injectDB(conn) {\n\t\tif (stocks) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t// stocks = await conn.db(process.env.STOCK_DATA).collection('historical_prices');\n\t\t\tstocks = await conn.db('stock_data').collection('historical_prices');\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to establish collection handles in dataDAO: ${e}`);\n\t\t}\n\t}\n\n\tstatic async getPrices({\n\t\t// here's where the default parameters are set for the getMovies method\n\t\tfilters = null,\n\t\tpage = 0,\n\t\tpricesPerPage = 20,\n\t} = {}) {\n\t\tlet cursor;\n\n\t\ttry {\n\t\t\tcursor = await stocks.find();\n\n\t\t\t// console.log(cursor.toArray());\n\t\t\t// .project(project)\n\t\t\t// .sort(sort);\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to issue find command, ${e}`);\n\t\t\treturn {pricesList: [], totalNumPrices: 0};\n\t\t}\n\n\t\t// const pricesList = await cursor.toArray();\n\t\t// return {pricesList};\n\n\t\tconst displayCursor = cursor.skip(pricesPerPage * page).limit(pricesPerPage);\n\n\t\t// const pricesList = await displayCursor.toArray();\n\t\t// return {pricesList};\n\n\t\ttry {\n\t\t\tconst pricesList = await displayCursor.toArray();\n\t\t\tconst totalNumPrices =\n\t\t\t\tpage === 0 ? await stocks.countDocuments({ticker: 'AAPL'}) : 0;\n\n\t\t\treturn {pricesList, totalNumPrices};\n\t\t} catch (e) {\n\t\t\tconsole.error(\n\t\t\t\t`Unable to convert cursor to array or problem counting documents, ${e}`\n\t\t\t);\n\t\t\treturn {pricesList: [], totalNumPrices: 0};\n\t\t}\n\t}\n\n\tstatic async insertStockHist() {\n\t\t// var myDate = new Date(2014, 11, 12, 0, 0);\n\t\tvar myDate = new Date('10/16/1995Z');\n\n\t\ttry {\n\t\t\tlet upsertResult = await stocks.updateOne(\n\t\t\t\t// this is the \"query\" portion of the update\n\t\t\t\t{ticker: 'AAPL', timestamp: myDate},\n\t\t\t\t// this is the update\n\t\t\t\t{\n\t\t\t\t\t$set: {\n\t\t\t\t\t\t// timestamp: new Date(),\n\t\t\t\t\t\ttimestamp: myDate,\n\t\t\t\t\t\topen: 154.1,\n\t\t\t\t\t\thigh: 164.1,\n\t\t\t\t\t\tlow: 124.1,\n\t\t\t\t\t\tclose: 134.1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t// this is the options document. We've specified upsert: true, so if the\n\t\t\t\t// query doesn't find a document to update, it will be written instead as\n\t\t\t\t// a new document\n\t\t\t\t{upsert: true}\n\t\t\t);\n\n\t\t\t// console.log({upsertResult});\n\n\t\t\treturn {success: true};\n\t\t} catch (e) {\n\t\t\tconsole.error(`Error occurred while updating stock, ${e}`);\n\t\t\treturn {error: e};\n\t\t}\n\t}\n}\n"],"file":"dataDAO.js"}