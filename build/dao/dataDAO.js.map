{"version":3,"sources":["../../src/dao/dataDAO.js"],"names":["zips","stocks","DataDAO","conn","db","process","env","MFLIX_TR","collection","console","log","error","filters","page","zipsPerPage","queryParams","cursor","find","state","zipsList","totalNumZips","displayCursor","skip","limit","toArray","countDocuments","StockDataDAO","pricesPerPage","pricesList","totalNumPrices","ticker","myDate","Date","updateOne","timestamp","$set","open","high","low","close","upsert","upsertResult","success"],"mappings":"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","file":"dataDAO.js","sourcesContent":["let zips, stocks;\n\nexport class DataDAO {\n\tstatic async injectDB(conn) {\n\t\tif (zips) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t// movies = await conn.db(process.env.MFLIX_NS).collection('movies');\n\t\t\tzips = await conn.db(process.env.MFLIX_TR).collection('zips');\n\t\t\t// zips = await conn.db(process.env.MFLIX_TR).collection('movies');\n\t\t\t// console.log('zip', zips);\n\t\t\tconsole.log('zip inj');\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to establish collection handles in dataDAO: ${e}`);\n\t\t}\n\t}\n\n\tstatic async getZips({\n\t\t// here's where the default parameters are set for the getMovies method\n\t\tfilters = null,\n\t\tpage = 0,\n\t\tzipsPerPage = 20,\n\t} = {}) {\n\t\tlet queryParams = {};\n\t\t// if (filters) {\n\t\t// \tif ('text' in filters) {\n\t\t// \t\tqueryParams = this.textSearchQuery(filters['text']);\n\t\t// \t} else if ('cast' in filters) {\n\t\t// \t\tqueryParams = this.castSearchQuery(filters['cast']);\n\t\t// \t} else if ('genre' in filters) {\n\t\t// \t\tqueryParams = this.genreSearchQuery(filters['genre']);\n\t\t// \t}\n\t\t// }\n\n\t\t// let { query = {}, project = {}, sort = DEFAULT_SORT } = queryParams;\n\t\tlet cursor;\n\n\t\t// const resa = await zips.find({state: 'AL'});\n\n\t\t// const res = await resa.toArray();\n\t\t// console.log('running getzips', res, '-----');\n\t\ttry {\n\t\t\tcursor = await zips.find({state: 'AL'});\n\n\t\t\t// console.log(cursor.toArray());\n\t\t\t// .project(project)\n\t\t\t// .sort(sort);\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to issue find command, ${e}`);\n\t\t\treturn {zipsList: [], totalNumZips: 0};\n\t\t}\n\n\t\t// const zipsList = await cursor.toArray();\n\t\t// return {zipsList};\n\n\t\tconst displayCursor = cursor.skip(zipsPerPage * page).limit(zipsPerPage);\n\n\t\t// const zipsList = await displayCursor.toArray();\n\t\t// return {zipsList};\n\n\t\ttry {\n\t\t\tconst zipsList = await displayCursor.toArray();\n\t\t\t// const totalNumZips = page === 0 ? await zips.countDocuments(query) : 0;\n\t\t\tconst totalNumZips = page === 0 ? await zips.countDocuments({state: 'AL'}) : 0;\n\n\t\t\treturn {zipsList, totalNumZips};\n\t\t} catch (e) {\n\t\t\tconsole.error(\n\t\t\t\t`Unable to convert cursor to array or problem counting documents, ${e}`\n\t\t\t);\n\t\t\treturn {zipsList: [], totalNumZips: 0};\n\t\t}\n\t}\n}\n\nexport class StockDataDAO {\n\tstatic async injectDB(conn) {\n\t\tif (stocks) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t// stocks = await conn.db(process.env.STOCK_DATA).collection('historical_prices');\n\t\t\tstocks = await conn.db('stock_data').collection('historical_prices');\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to establish collection handles in dataDAO: ${e}`);\n\t\t}\n\t}\n\n\tstatic async getPrices({\n\t\t// here's where the default parameters are set for the getMovies method\n\t\tfilters = null,\n\t\tpage = 0,\n\t\tpricesPerPage = 20,\n\t} = {}) {\n\t\tlet cursor;\n\n\t\ttry {\n\t\t\tcursor = await stocks.find();\n\n\t\t\t// console.log(cursor.toArray());\n\t\t\t// .project(project)\n\t\t\t// .sort(sort);\n\t\t} catch (e) {\n\t\t\tconsole.error(`Unable to issue find command, ${e}`);\n\t\t\treturn {pricesList: [], totalNumPrices: 0};\n\t\t}\n\n\t\t// const pricesList = await cursor.toArray();\n\t\t// return {pricesList};\n\n\t\tconst displayCursor = cursor.skip(pricesPerPage * page).limit(pricesPerPage);\n\n\t\t// const pricesList = await displayCursor.toArray();\n\t\t// return {pricesList};\n\n\t\ttry {\n\t\t\tconst pricesList = await displayCursor.toArray();\n\t\t\tconst totalNumPrices =\n\t\t\t\tpage === 0 ? await stocks.countDocuments({ticker: 'AAPL'}) : 0;\n\n\t\t\treturn {pricesList, totalNumPrices};\n\t\t} catch (e) {\n\t\t\tconsole.error(\n\t\t\t\t`Unable to convert cursor to array or problem counting documents, ${e}`\n\t\t\t);\n\t\t\treturn {pricesList: [], totalNumPrices: 0};\n\t\t}\n\t}\n\n\tstatic async insertStockHist() {\n\t\t// var myDate = new Date(2014, 11, 12, 0, 0);\n\t\tvar myDate = new Date('10/16/1995Z');\n\n\t\ttry {\n\t\t\tlet upsertResult = await stocks.updateOne(\n\t\t\t\t// this is the \"query\" portion of the update\n\t\t\t\t{ticker: 'AAPL', timestamp: myDate},\n\t\t\t\t// this is the update\n\t\t\t\t{\n\t\t\t\t\t$set: {\n\t\t\t\t\t\t// timestamp: new Date(),\n\t\t\t\t\t\ttimestamp: myDate,\n\t\t\t\t\t\topen: 154.1,\n\t\t\t\t\t\thigh: 164.1,\n\t\t\t\t\t\tlow: 124.1,\n\t\t\t\t\t\tclose: 134.1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t// this is the options document. We've specified upsert: true, so if the\n\t\t\t\t// query doesn't find a document to update, it will be written instead as\n\t\t\t\t// a new document\n\t\t\t\t{upsert: true}\n\t\t\t);\n\n\t\t\t// console.log({upsertResult});\n\n\t\t\treturn {success: true};\n\t\t} catch (e) {\n\t\t\tconsole.error(`Error occurred while updating stock, ${e}`);\n\t\t\treturn {error: e};\n\t\t}\n\t}\n}\n"]}